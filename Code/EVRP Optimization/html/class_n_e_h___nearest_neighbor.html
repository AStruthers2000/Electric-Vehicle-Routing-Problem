<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Electric Vehicle Routing Problem: NEH_NearestNeighbor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Electric Vehicle Routing Problem
   </div>
   <div id="projectbrief">A genetic algorithm implementation to optimize the capacitated electric vehicle routing problem</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_n_e_h___nearest_neighbor.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="class_n_e_h___nearest_neighbor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">NEH_NearestNeighbor Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_n_e_h___nearest_neighbor_8h_source.html">NEH_NearestNeighbor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for NEH_NearestNeighbor:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_n_e_h___nearest_neighbor.png" usemap="#NEH_5FNearestNeighbor_map" alt=""/>
  <map id="NEH_5FNearestNeighbor_map" name="NEH_5FNearestNeighbor_map">
<area href="class_algorithm_base.html" alt="AlgorithmBase" shape="rect" coords="0,0,141,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:struct_n_e_h___nearest_neighbor_1_1node__distances" id="r_struct_n_e_h___nearest_neighbor_1_1node__distances"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_e_h___nearest_neighbor.html#struct_n_e_h___nearest_neighbor_1_1node__distances">node_distances</a></td></tr>
<tr class="separator:struct_n_e_h___nearest_neighbor_1_1node__distances"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a48a5f696771be763a2a4f193e6957b00" id="r_a48a5f696771be763a2a4f193e6957b00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_e_h___nearest_neighbor.html#a48a5f696771be763a2a4f193e6957b00">NEH_NearestNeighbor</a> (const <a class="el" href="_graph_structure_8h.html#struct_e_v_r_p___data">EVRP_Data</a> &amp;data)</td></tr>
<tr class="separator:a48a5f696771be763a2a4f193e6957b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181ec27fd392521ea1f5d60f6d4b4de7" id="r_a181ec27fd392521ea1f5d60f6d4b4de7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_e_h___nearest_neighbor.html#a181ec27fd392521ea1f5d60f6d4b4de7">Optimize</a> (vector&lt; int &gt; &amp;bestTour, float &amp;bestDistance) override</td></tr>
<tr class="memdesc:a181ec27fd392521ea1f5d60f6d4b4de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses NEH concepts to try and minimize the distance of each subtour in the route. We will first come up with all of the subtours through the graph with inventory capacity as our only constraint, using the nearest neighbor approach. This will get us a set of subtours through customer nodes, where at the end of the subtour, we must return to the depot. We will then use NEH concepts to order the nodes in each subtour in the way that results in the minimum "makespan" of the route, aka the distance of that route.  <br /></td></tr>
<tr class="separator:a181ec27fd392521ea1f5d60f6d4b4de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_algorithm_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_algorithm_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_algorithm_base.html">AlgorithmBase</a></td></tr>
<tr class="memitem:a77303cd98d372fabb7d28d687c81859b inherit pub_methods_class_algorithm_base" id="r_a77303cd98d372fabb7d28d687c81859b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm_base.html#a77303cd98d372fabb7d28d687c81859b">AlgorithmBase</a> ()</td></tr>
<tr class="separator:a77303cd98d372fabb7d28d687c81859b inherit pub_methods_class_algorithm_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f6568763eca8c467a78c5034d2c8de inherit pub_methods_class_algorithm_base" id="r_a37f6568763eca8c467a78c5034d2c8de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm_base.html#a37f6568763eca8c467a78c5034d2c8de">AlgorithmBase</a> (const string &amp;algorithm_name, const <a class="el" href="_graph_structure_8h.html#struct_e_v_r_p___data">EVRP_Data</a> &amp;data)</td></tr>
<tr class="separator:a37f6568763eca8c467a78c5034d2c8de inherit pub_methods_class_algorithm_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01862a2fa8e29b154e6d95c1287a598e inherit pub_methods_class_algorithm_base" id="r_a01862a2fa8e29b154e6d95c1287a598e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm_base.html#a01862a2fa8e29b154e6d95c1287a598e">~AlgorithmBase</a> ()</td></tr>
<tr class="separator:a01862a2fa8e29b154e6d95c1287a598e inherit pub_methods_class_algorithm_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b1731329fc03bb93d011594b972573 inherit pub_methods_class_algorithm_base" id="r_aa5b1731329fc03bb93d011594b972573"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm_base.html#aa5b1731329fc03bb93d011594b972573">GetName</a> ()</td></tr>
<tr class="separator:aa5b1731329fc03bb93d011594b972573 inherit pub_methods_class_algorithm_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bfaeeb0d423d73f4ec9b87ffbf1c08 inherit pub_methods_class_algorithm_base" id="r_a91bfaeeb0d423d73f4ec9b87ffbf1c08"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm_base.html#a91bfaeeb0d423d73f4ec9b87ffbf1c08">GetHyperParameters</a> ()</td></tr>
<tr class="separator:a91bfaeeb0d423d73f4ec9b87ffbf1c08 inherit pub_methods_class_algorithm_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a4911930144907ce7a07db34fdc5ee8e1" id="r_a4911930144907ce7a07db34fdc5ee8e1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="class_n_e_h___nearest_neighbor.html#struct_n_e_h___nearest_neighbor_1_1node__distances">NEH_NearestNeighbor::node_distances</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_e_h___nearest_neighbor.html#a4911930144907ce7a07db34fdc5ee8e1">node_distances</a></td></tr>
<tr class="separator:a4911930144907ce7a07db34fdc5ee8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac5e7990cabd81eec17a0a9b22610cacd" id="r_ac5e7990cabd81eec17a0a9b22610cacd"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_e_h___nearest_neighbor.html#ac5e7990cabd81eec17a0a9b22610cacd">NEH_Calculation</a> (const vector&lt; <a class="el" href="struct_node.html">Node</a> &gt; &amp;subtour) const</td></tr>
<tr class="memdesc:ac5e7990cabd81eec17a0a9b22610cacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use NEH concepts to find the best ordering of nodes in each subtour. we need to figure out the optimal ordering of the nodes in the subtour to minimize the distance in each subtour. We will use NEH concepts to do this.  <br /></td></tr>
<tr class="separator:ac5e7990cabd81eec17a0a9b22610cacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:aabdd648e7d16ac1c0020bcf6e2b8df39" id="r_aabdd648e7d16ac1c0020bcf6e2b8df39"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_e_h___nearest_neighbor.html#aabdd648e7d16ac1c0020bcf6e2b8df39">GetNearestUnvisitedNode</a> (const vector&lt; <a class="el" href="struct_node.html">Node</a> &gt; &amp;customer_nodes, const vector&lt; <a class="el" href="struct_node.html">Node</a> &gt; &amp;visited_nodes, const <a class="el" href="struct_node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:aabdd648e7d16ac1c0020bcf6e2b8df39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the closest node to the provided node while filtering the graph by nodes we have already visited.  <br /></td></tr>
<tr class="separator:aabdd648e7d16ac1c0020bcf6e2b8df39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1959b3fa3963b15d0d22f29a68020a49" id="r_a1959b3fa3963b15d0d22f29a68020a49"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_e_h___nearest_neighbor.html#a1959b3fa3963b15d0d22f29a68020a49">GetNearestNode</a> (const vector&lt; <a class="el" href="struct_node.html">Node</a> &gt; &amp;customer_nodes, const <a class="el" href="struct_node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:a1959b3fa3963b15d0d22f29a68020a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the nearest node to any given node out of a set of possible nodes.  <br /></td></tr>
<tr class="separator:a1959b3fa3963b15d0d22f29a68020a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_algorithm_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_algorithm_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_algorithm_base.html">AlgorithmBase</a></td></tr>
<tr class="memitem:a095b80e35fcf63e5f623730772f9f826 inherit pro_methods_class_algorithm_base" id="r_a095b80e35fcf63e5f623730772f9f826"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm_base.html#a095b80e35fcf63e5f623730772f9f826">SetHyperParameters</a> (const vector&lt; string &gt; &amp;params)</td></tr>
<tr class="separator:a095b80e35fcf63e5f623730772f9f826 inherit pro_methods_class_algorithm_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_class_algorithm_base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_class_algorithm_base')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="class_algorithm_base.html">AlgorithmBase</a></td></tr>
<tr class="memitem:aea675ca00b3e47afe75b413195a16ca0 inherit pro_static_methods_class_algorithm_base" id="r_aea675ca00b3e47afe75b413195a16ca0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm_base.html#aea675ca00b3e47afe75b413195a16ca0">PrintIfTheTimeIsRight</a> (const string &amp;alg, const int &amp;current, const int &amp;max)</td></tr>
<tr class="separator:aea675ca00b3e47afe75b413195a16ca0 inherit pro_static_methods_class_algorithm_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_algorithm_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_algorithm_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_algorithm_base.html">AlgorithmBase</a></td></tr>
<tr class="memitem:ad83df42564aa8a94f169ab78b4625731 inherit pro_attribs_class_algorithm_base" id="r_ad83df42564aa8a94f169ab78b4625731"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_graph_structure_8h.html#struct_e_v_r_p___data">EVRP_Data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm_base.html#ad83df42564aa8a94f169ab78b4625731">problem_data</a></td></tr>
<tr class="separator:ad83df42564aa8a94f169ab78b4625731 inherit pro_attribs_class_algorithm_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f24e23a948de9928cac6fa78422e292 inherit pro_attribs_class_algorithm_base" id="r_a0f24e23a948de9928cac6fa78422e292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vehicle.html">Vehicle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm_base.html#a0f24e23a948de9928cac6fa78422e292">vehicle</a></td></tr>
<tr class="separator:a0f24e23a948de9928cac6fa78422e292 inherit pro_attribs_class_algorithm_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="struct_n_e_h___nearest_neighbor_1_1node__distances" id="struct_n_e_h___nearest_neighbor_1_1node__distances"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_n_e_h___nearest_neighbor_1_1node__distances">&#9670;&#160;</a></span>NEH_NearestNeighbor::node_distances</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct NEH_NearestNeighbor::node_distances</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a2cf31df450ececdd798c2135be8447ec" name="a2cf31df450ececdd798c2135be8447ec"></a>map&lt; <a class="el" href="struct_node.html">Node</a>, float &gt;</td>
<td class="fieldname">
distance_map</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ac7263d295f322dbdd471e6d73e0c5de7" name="ac7263d295f322dbdd471e6d73e0c5de7"></a><a class="el" href="struct_node.html">Node</a></td>
<td class="fieldname">
me</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4911930144907ce7a07db34fdc5ee8e1" name="a4911930144907ce7a07db34fdc5ee8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4911930144907ce7a07db34fdc5ee8e1">&#9670;&#160;</a></span>node_distances</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="class_n_e_h___nearest_neighbor.html#struct_n_e_h___nearest_neighbor_1_1node__distances">NEH_NearestNeighbor::node_distances</a> <a class="el" href="class_n_e_h___nearest_neighbor.html#struct_n_e_h___nearest_neighbor_1_1node__distances">NEH_NearestNeighbor::node_distances</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a48a5f696771be763a2a4f193e6957b00" name="a48a5f696771be763a2a4f193e6957b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a5f696771be763a2a4f193e6957b00">&#9670;&#160;</a></span>NEH_NearestNeighbor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NEH_NearestNeighbor::NEH_NearestNeighbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_graph_structure_8h.html#struct_e_v_r_p___data">EVRP_Data</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">    7</span>                                               :</div>
<div class="line"><span class="lineno">    8</span>        <a class="code hl_function" href="class_algorithm_base.html#a77303cd98d372fabb7d28d687c81859b">AlgorithmBase</a>(<span class="stringliteral">&quot;NEH with Nearest Neighbor Subtours&quot;</span>, data)</div>
<div class="line"><span class="lineno">    9</span>    {</div>
<div class="line"><span class="lineno">   10</span>        vector&lt;string&gt; <a class="code hl_variable" href="class_algorithm_base.html#ad9d01d6a7dbba7aeb833df5d3e9e2127">hyper_parameters</a>;</div>
<div class="line"><span class="lineno">   11</span>        <a class="code hl_variable" href="class_algorithm_base.html#ad9d01d6a7dbba7aeb833df5d3e9e2127">hyper_parameters</a>.emplace_back(<span class="stringliteral">&quot;None&quot;</span>);</div>
<div class="line"><span class="lineno">   12</span>        <a class="code hl_function" href="class_algorithm_base.html#a095b80e35fcf63e5f623730772f9f826">SetHyperParameters</a>(<a class="code hl_variable" href="class_algorithm_base.html#ad9d01d6a7dbba7aeb833df5d3e9e2127">hyper_parameters</a>);</div>
<div class="line"><span class="lineno">   13</span>    }</div>
<div class="ttc" id="aclass_algorithm_base_html_a095b80e35fcf63e5f623730772f9f826"><div class="ttname"><a href="class_algorithm_base.html#a095b80e35fcf63e5f623730772f9f826">AlgorithmBase::SetHyperParameters</a></div><div class="ttdeci">void SetHyperParameters(const vector&lt; string &gt; &amp;params)</div><div class="ttdef"><b>Definition</b> AlgorithmBase.h:32</div></div>
<div class="ttc" id="aclass_algorithm_base_html_a77303cd98d372fabb7d28d687c81859b"><div class="ttname"><a href="class_algorithm_base.html#a77303cd98d372fabb7d28d687c81859b">AlgorithmBase::AlgorithmBase</a></div><div class="ttdeci">AlgorithmBase()</div></div>
<div class="ttc" id="aclass_algorithm_base_html_ad9d01d6a7dbba7aeb833df5d3e9e2127"><div class="ttname"><a href="class_algorithm_base.html#ad9d01d6a7dbba7aeb833df5d3e9e2127">AlgorithmBase::hyper_parameters</a></div><div class="ttdeci">vector&lt; string &gt; hyper_parameters</div><div class="ttdef"><b>Definition</b> AlgorithmBase.h:47</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_algorithm_base.html#ad9d01d6a7dbba7aeb833df5d3e9e2127">AlgorithmBase::hyper_parameters</a>, and <a class="el" href="class_algorithm_base.html#a095b80e35fcf63e5f623730772f9f826">AlgorithmBase::SetHyperParameters()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1959b3fa3963b15d0d22f29a68020a49" name="a1959b3fa3963b15d0d22f29a68020a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1959b3fa3963b15d0d22f29a68020a49">&#9670;&#160;</a></span>GetNearestNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> NEH_NearestNeighbor::GetNearestNode </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="struct_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>customer_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the nearest node to any given node out of a set of possible nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">customer_nodes</td><td>All customer nodes in which to search </td></tr>
    <tr><td class="paramname">node</td><td>The node that we are searching around </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The closest node to the input node param </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  184</span>{</div>
<div class="line"><span class="lineno">  185</span>    <a class="code hl_struct" href="struct_node.html">Node</a> closest_node = node;</div>
<div class="line"><span class="lineno">  186</span>    <span class="keywordtype">float</span> smallest_distance = numeric_limits&lt;float&gt;::max();</div>
<div class="line"><span class="lineno">  187</span>    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> other : customer_nodes)</div>
<div class="line"><span class="lineno">  188</span>    {</div>
<div class="line"><span class="lineno">  189</span>        <span class="keyword">const</span> <span class="keywordtype">float</span> node_distance = <a class="code hl_function" href="class_helper_functions.html#a8758a2fea744ade8b105386fdce43ba9">HelperFunctions::CalculateInterNodeDistance</a>(node, other);</div>
<div class="line"><span class="lineno">  190</span>        <span class="keywordflow">if</span>(node_distance &lt; smallest_distance &amp;&amp; node_distance &gt; 1)</div>
<div class="line"><span class="lineno">  191</span>        {</div>
<div class="line"><span class="lineno">  192</span>            closest_node = other;</div>
<div class="line"><span class="lineno">  193</span>            smallest_distance = node_distance;</div>
<div class="line"><span class="lineno">  194</span>        }</div>
<div class="line"><span class="lineno">  195</span>    }</div>
<div class="line"><span class="lineno">  196</span>    <span class="keywordflow">return</span> closest_node;</div>
<div class="line"><span class="lineno">  197</span>}</div>
<div class="ttc" id="aclass_helper_functions_html_a8758a2fea744ade8b105386fdce43ba9"><div class="ttname"><a href="class_helper_functions.html#a8758a2fea744ade8b105386fdce43ba9">HelperFunctions::CalculateInterNodeDistance</a></div><div class="ttdeci">static float CalculateInterNodeDistance(const Node &amp;node1, const Node &amp;node2)</div><div class="ttdef"><b>Definition</b> HelperFunctions.cpp:83</div></div>
<div class="ttc" id="astruct_node_html"><div class="ttname"><a href="struct_node.html">Node</a></div><div class="ttdef"><b>Definition</b> GraphStructure.h:34</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_helper_functions.html#a8758a2fea744ade8b105386fdce43ba9">HelperFunctions::CalculateInterNodeDistance()</a>.</p>

</div>
</div>
<a id="aabdd648e7d16ac1c0020bcf6e2b8df39" name="aabdd648e7d16ac1c0020bcf6e2b8df39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabdd648e7d16ac1c0020bcf6e2b8df39">&#9670;&#160;</a></span>GetNearestUnvisitedNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_node.html">Node</a> NEH_NearestNeighbor::GetNearestUnvisitedNode </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="struct_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>customer_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="struct_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the closest node to the provided node while filtering the graph by nodes we have already visited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">customer_nodes</td><td>All customer nodes in this problem instance </td></tr>
    <tr><td class="paramname">visited_nodes</td><td>All nodes we have already visited in previous iterations </td></tr>
    <tr><td class="paramname">node</td><td>We want to find the closest unvisited node to this node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>We return the closest node to the node param </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  156</span>{</div>
<div class="line"><span class="lineno">  157</span>    vector&lt;Node&gt; unvisited_nodes;</div>
<div class="line"><span class="lineno">  158</span>    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> customer : customer_nodes)</div>
<div class="line"><span class="lineno">  159</span>    {</div>
<div class="line"><span class="lineno">  160</span>        <span class="keywordtype">bool</span> has_visited = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  161</span>        <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> visited : visited_nodes)</div>
<div class="line"><span class="lineno">  162</span>        {</div>
<div class="line"><span class="lineno">  163</span>            <span class="keywordflow">if</span>(customer.index == visited.index)</div>
<div class="line"><span class="lineno">  164</span>            {</div>
<div class="line"><span class="lineno">  165</span>                has_visited = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  166</span>            }</div>
<div class="line"><span class="lineno">  167</span>        }</div>
<div class="line"><span class="lineno">  168</span>        <span class="keywordflow">if</span>(!has_visited)</div>
<div class="line"><span class="lineno">  169</span>        {</div>
<div class="line"><span class="lineno">  170</span>            unvisited_nodes.push_back(customer);</div>
<div class="line"><span class="lineno">  171</span>        }</div>
<div class="line"><span class="lineno">  172</span>    }</div>
<div class="line"><span class="lineno">  173</span>    <span class="comment">//we just call GetNearestNode on the unvisited node subset of the complete customer graph</span></div>
<div class="line"><span class="lineno">  174</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="class_n_e_h___nearest_neighbor.html#a1959b3fa3963b15d0d22f29a68020a49">GetNearestNode</a>(unvisited_nodes, node);</div>
<div class="line"><span class="lineno">  175</span>}</div>
<div class="ttc" id="aclass_n_e_h___nearest_neighbor_html_a1959b3fa3963b15d0d22f29a68020a49"><div class="ttname"><a href="class_n_e_h___nearest_neighbor.html#a1959b3fa3963b15d0d22f29a68020a49">NEH_NearestNeighbor::GetNearestNode</a></div><div class="ttdeci">static Node GetNearestNode(const vector&lt; Node &gt; &amp;customer_nodes, const Node &amp;node)</div><div class="ttdoc">Find the nearest node to any given node out of a set of possible nodes.</div><div class="ttdef"><b>Definition</b> NEH_NearestNeighbor.cpp:183</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="class_n_e_h___nearest_neighbor.html#a1959b3fa3963b15d0d22f29a68020a49">GetNearestNode()</a>.</p>

</div>
</div>
<a id="ac5e7990cabd81eec17a0a9b22610cacd" name="ac5e7990cabd81eec17a0a9b22610cacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e7990cabd81eec17a0a9b22610cacd">&#9670;&#160;</a></span>NEH_Calculation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; NEH_NearestNeighbor::NEH_Calculation </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="struct_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subtour</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use NEH concepts to find the best ordering of nodes in each subtour. we need to figure out the optimal ordering of the nodes in the subtour to minimize the distance in each subtour. We will use NEH concepts to do this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subtour</td><td>The unoptimized subtour generated by the nearest neighbor approach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The optimal ordering of the nodes inside the given subtour </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  207</span>{</div>
<div class="line"><span class="lineno">  208</span>    <span class="comment">//if there is only one node in the subtour, we want to return. it is already &quot;ordered&quot;</span></div>
<div class="line"><span class="lineno">  209</span>    <span class="keywordflow">if</span>(subtour.size() == 1) <span class="keywordflow">return</span> {subtour[0].index};</div>
<div class="line"><span class="lineno">  210</span> </div>
<div class="line"><span class="lineno">  211</span>    <span class="comment">//take the provided Node subtour and construct a list of just these node&#39;s indices because</span></div>
<div class="line"><span class="lineno">  212</span>    <span class="comment">//the vehicle SimulateDrive method takes an integer index-encoded tour</span></div>
<div class="line"><span class="lineno">  213</span>    vector&lt;int&gt; index_encoded_subtour;</div>
<div class="line"><span class="lineno">  214</span>    index_encoded_subtour.reserve(subtour.size());</div>
<div class="line"><span class="lineno">  215</span>    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;node : subtour)</div>
<div class="line"><span class="lineno">  216</span>    {</div>
<div class="line"><span class="lineno">  217</span>        index_encoded_subtour.push_back(node.index);</div>
<div class="line"><span class="lineno">  218</span>    }</div>
<div class="line"><span class="lineno">  219</span> </div>
<div class="line"><span class="lineno">  220</span>    <span class="comment">//start with L = 2</span></div>
<div class="line"><span class="lineno">  221</span>    <span class="keywordtype">int</span> L = 2;</div>
<div class="line"><span class="lineno">  222</span>    </div>
<div class="line"><span class="lineno">  223</span>    <span class="comment">//vector to track the best partial subtour (aka the partial subtour with the smallest &quot;makespan&quot;)</span></div>
<div class="line"><span class="lineno">  224</span>    vector&lt;int&gt; best_partial;</div>
<div class="line"><span class="lineno">  225</span>    </div>
<div class="line"><span class="lineno">  226</span>    <span class="comment">//the complete partial subtour, which starts with element 0 of the provided subtour</span></div>
<div class="line"><span class="lineno">  227</span>    vector&lt;int&gt; partial_subtour;</div>
<div class="line"><span class="lineno">  228</span>    partial_subtour.push_back(index_encoded_subtour[0]);</div>
<div class="line"><span class="lineno">  229</span> </div>
<div class="line"><span class="lineno">  230</span>    <span class="comment">//iterate until L = subtour size + 1</span></div>
<div class="line"><span class="lineno">  231</span>    <span class="keywordflow">do</span></div>
<div class="line"><span class="lineno">  232</span>    {</div>
<div class="line"><span class="lineno">  233</span>        <span class="comment">//start with the current best distance equal to the largest float number</span></div>
<div class="line"><span class="lineno">  234</span>        <span class="keywordtype">float</span> best_dist = numeric_limits&lt;float&gt;::max();</div>
<div class="line"><span class="lineno">  235</span> </div>
<div class="line"><span class="lineno">  236</span>        <span class="comment">//we insert the next node into every possible point inside of the current subtour and calculate the distance</span></div>
<div class="line"><span class="lineno">  237</span>        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; partial_subtour.size() + 1; i++)</div>
<div class="line"><span class="lineno">  238</span>        {</div>
<div class="line"><span class="lineno">  239</span>            <span class="comment">//create a temporary subtour vector that we can insert an element into</span></div>
<div class="line"><span class="lineno">  240</span>            <span class="comment">//we create this temporary subtour every iteration so that we don&#39;t need to remove the element</span></div>
<div class="line"><span class="lineno">  241</span>            <span class="comment">//it&#39;ll just override each iteration. we could definitely just remove the inserted element after </span></div>
<div class="line"><span class="lineno">  242</span>            <span class="comment">//calculating, if this becomes an issue</span></div>
<div class="line"><span class="lineno">  243</span>            vector&lt;int&gt; temp_subtour = {partial_subtour.begin(), partial_subtour.end()};</div>
<div class="line"><span class="lineno">  244</span> </div>
<div class="line"><span class="lineno">  245</span>            <span class="comment">//create a vector iterator at index i of the temporary subtour vector</span></div>
<div class="line"><span class="lineno">  246</span>            <span class="keyword">const</span> <span class="keyword">auto</span> index = temp_subtour.begin() + <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span> <span class="keywordtype">long</span><span class="keyword">&gt;</span>(i);</div>
<div class="line"><span class="lineno">  247</span> </div>
<div class="line"><span class="lineno">  248</span>            <span class="comment">//insert element L (index L - 1) into the subtour</span></div>
<div class="line"><span class="lineno">  249</span>            temp_subtour.insert(index, index_encoded_subtour[L-1]);</div>
<div class="line"><span class="lineno">  250</span> </div>
<div class="line"><span class="lineno">  251</span>            <span class="comment">//calculate the distance of the partial subtour (all constraints are implemented in Vehicle::SimulateDrive)</span></div>
<div class="line"><span class="lineno">  252</span>            <span class="keyword">const</span> <span class="keywordtype">float</span> dist = <a class="code hl_variable" href="class_algorithm_base.html#a0f24e23a948de9928cac6fa78422e292">vehicle</a>-&gt;<a class="code hl_function" href="class_vehicle.html#a9e45048058f35d303d2c17ea1f7e657d">SimulateDrive</a>(temp_subtour);</div>
<div class="line"><span class="lineno">  253</span>            <span class="keywordflow">if</span>(dist &lt; best_dist)</div>
<div class="line"><span class="lineno">  254</span>            {</div>
<div class="line"><span class="lineno">  255</span>                best_partial = temp_subtour;</div>
<div class="line"><span class="lineno">  256</span>                best_dist = dist;</div>
<div class="line"><span class="lineno">  257</span>            }</div>
<div class="line"><span class="lineno">  258</span>        }</div>
<div class="line"><span class="lineno">  259</span>        <span class="comment">//copy the best subtour into partial_subtour</span></div>
<div class="line"><span class="lineno">  260</span>        <span class="comment">//the best partial subtour will have 1 additional element, so this operation increases the size of the partial_subtour by 1</span></div>
<div class="line"><span class="lineno">  261</span>        partial_subtour = {best_partial.begin(), best_partial.end()};</div>
<div class="line"><span class="lineno">  262</span> </div>
<div class="line"><span class="lineno">  263</span>        <span class="comment">//Increment L so that the next iteration will sort the next element with NEH methodologies</span></div>
<div class="line"><span class="lineno">  264</span>        L++;</div>
<div class="line"><span class="lineno">  265</span>    } <span class="keywordflow">while</span>(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(L) &lt; subtour.size() + 1);</div>
<div class="line"><span class="lineno">  266</span> </div>
<div class="line"><span class="lineno">  267</span>    <span class="comment">//return the subtour </span></div>
<div class="line"><span class="lineno">  268</span>    <span class="keywordflow">return</span> partial_subtour;</div>
<div class="line"><span class="lineno">  269</span>}</div>
<div class="ttc" id="aclass_algorithm_base_html_a0f24e23a948de9928cac6fa78422e292"><div class="ttname"><a href="class_algorithm_base.html#a0f24e23a948de9928cac6fa78422e292">AlgorithmBase::vehicle</a></div><div class="ttdeci">Vehicle * vehicle</div><div class="ttdef"><b>Definition</b> AlgorithmBase.h:29</div></div>
<div class="ttc" id="aclass_vehicle_html_a9e45048058f35d303d2c17ea1f7e657d"><div class="ttname"><a href="class_vehicle.html#a9e45048058f35d303d2c17ea1f7e657d">Vehicle::SimulateDrive</a></div><div class="ttdeci">float SimulateDrive(const vector&lt; int &gt; &amp;desiredRoute, bool verbose=false)</div><div class="ttdef"><b>Definition</b> Vehicle.cpp:27</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="struct_node.html#ac8055cdbda20cacce417192557741ab8">Node::index</a>, <a class="el" href="class_vehicle.html#a9e45048058f35d303d2c17ea1f7e657d">Vehicle::SimulateDrive()</a>, and <a class="el" href="class_algorithm_base.html#a0f24e23a948de9928cac6fa78422e292">AlgorithmBase::vehicle</a>.</p>

</div>
</div>
<a id="a181ec27fd392521ea1f5d60f6d4b4de7" name="a181ec27fd392521ea1f5d60f6d4b4de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181ec27fd392521ea1f5d60f6d4b4de7">&#9670;&#160;</a></span>Optimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NEH_NearestNeighbor::Optimize </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>bestTour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>bestDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses NEH concepts to try and minimize the distance of each subtour in the route. We will first come up with all of the subtours through the graph with inventory capacity as our only constraint, using the nearest neighbor approach. This will get us a set of subtours through customer nodes, where at the end of the subtour, we must return to the depot. We will then use NEH concepts to order the nodes in each subtour in the way that results in the minimum "makespan" of the route, aka the distance of that route. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bestTour</td><td>The best complete tour through all the customer nodes </td></tr>
    <tr><td class="paramname">bestDistance</td><td>The distance of the best tour </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_algorithm_base.html#a7914567a99ecc52383e01fda80ef9aad">AlgorithmBase</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   16</span>{</div>
<div class="line"><span class="lineno">   17</span>    <span class="comment">/*</span></div>
<div class="line"><span class="lineno">   18</span><span class="comment">     * First, we need to generate our tours using NN. We will get all of the customer nodes,</span></div>
<div class="line"><span class="lineno">   19</span><span class="comment">     * then select the closest node to the depot. We will then iterate, going to the next closest</span></div>
<div class="line"><span class="lineno">   20</span><span class="comment">     * node until we can&#39;t satisfy demand. This will form our nearest neighbor subtour set.</span></div>
<div class="line"><span class="lineno">   21</span><span class="comment">     */</span></div>
<div class="line"><span class="lineno">   22</span> </div>
<div class="line"><span class="lineno">   23</span>    <span class="comment">//depot node is always node 0</span></div>
<div class="line"><span class="lineno">   24</span>    <span class="keyword">const</span> <a class="code hl_struct" href="struct_node.html">Node</a> depot = <a class="code hl_variable" href="class_algorithm_base.html#ad83df42564aa8a94f169ab78b4625731">problem_data</a>.<a class="code hl_variable" href="_graph_structure_8h.html#aa06f172ac3f4b3ebef947ceb37e8d311">nodes</a>[0];</div>
<div class="line"><span class="lineno">   25</span> </div>
<div class="line"><span class="lineno">   26</span>    <span class="comment">//get all customer nodes for ease of calculation in the subtour generation</span></div>
<div class="line"><span class="lineno">   27</span>    vector&lt;Node&gt; customer_nodes;</div>
<div class="line"><span class="lineno">   28</span>    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;node : <a class="code hl_variable" href="class_algorithm_base.html#ad83df42564aa8a94f169ab78b4625731">problem_data</a>.nodes)</div>
<div class="line"><span class="lineno">   29</span>    {</div>
<div class="line"><span class="lineno">   30</span>        <span class="keywordflow">if</span>(node.demand &gt; 0)</div>
<div class="line"><span class="lineno">   31</span>        {</div>
<div class="line"><span class="lineno">   32</span>            customer_nodes.push_back(node);</div>
<div class="line"><span class="lineno">   33</span>        }</div>
<div class="line"><span class="lineno">   34</span>    }</div>
<div class="line"><span class="lineno">   35</span> </div>
<div class="line"><span class="lineno">   36</span>    <span class="comment">/*</span></div>
<div class="line"><span class="lineno">   37</span><span class="comment">    * Beginning of Nearest Neighbor Subtour generation</span></div>
<div class="line"><span class="lineno">   38</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">   39</span> </div>
<div class="line"><span class="lineno">   40</span>    vector&lt;vector&lt;Node&gt;&gt; subtours;</div>
<div class="line"><span class="lineno">   41</span>    vector&lt;Node&gt; visited_nodes;</div>
<div class="line"><span class="lineno">   42</span>    </div>
<div class="line"><span class="lineno">   43</span>    <span class="keywordflow">while</span>(visited_nodes.size() &lt; customer_nodes.size())</div>
<div class="line"><span class="lineno">   44</span>    {</div>
<div class="line"><span class="lineno">   45</span>        <span class="comment">//track the current subtour</span></div>
<div class="line"><span class="lineno">   46</span>        vector&lt;Node&gt; subtour;</div>
<div class="line"><span class="lineno">   47</span> </div>
<div class="line"><span class="lineno">   48</span>        <span class="comment">//start this subtour at the depot</span></div>
<div class="line"><span class="lineno">   49</span>        <a class="code hl_struct" href="struct_node.html">Node</a> current = depot;</div>
<div class="line"><span class="lineno">   50</span> </div>
<div class="line"><span class="lineno">   51</span>        <span class="comment">//start the subtour with a full vehicle</span></div>
<div class="line"><span class="lineno">   52</span>        <span class="keywordtype">int</span> capacity = <a class="code hl_variable" href="class_algorithm_base.html#ad83df42564aa8a94f169ab78b4625731">problem_data</a>.<a class="code hl_variable" href="_graph_structure_8h.html#ab01f753d693662a727c4ee4883562ab5">loadCapacity</a>;</div>
<div class="line"><span class="lineno">   53</span> </div>
<div class="line"><span class="lineno">   54</span>        <span class="comment">//iterate until we need to return to the depot</span></div>
<div class="line"><span class="lineno">   55</span>        <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><span class="lineno">   56</span>        {</div>
<div class="line"><span class="lineno">   57</span>            <span class="comment">//get the nearest unvisited node to the current node. the current node is the depot on the first iteration </span></div>
<div class="line"><span class="lineno">   58</span>            <span class="keyword">const</span> <a class="code hl_struct" href="struct_node.html">Node</a> nearest = <a class="code hl_function" href="class_n_e_h___nearest_neighbor.html#aabdd648e7d16ac1c0020bcf6e2b8df39">GetNearestUnvisitedNode</a>(customer_nodes, visited_nodes, current);</div>
<div class="line"><span class="lineno">   59</span> </div>
<div class="line"><span class="lineno">   60</span>            <span class="comment">//if the nearest demand is too large for our current capacity, we must return to the depot aka this subtour is over</span></div>
<div class="line"><span class="lineno">   61</span>            <span class="keywordflow">if</span> (nearest.<a class="code hl_variable" href="struct_node.html#a743d222e005f1160358a82d9329e5191">demand</a> &gt; capacity) <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">   62</span> </div>
<div class="line"><span class="lineno">   63</span>            <span class="comment">//set the current node to the nearest, symbolizing us &quot;going&quot; to that node</span></div>
<div class="line"><span class="lineno">   64</span>            current = nearest;</div>
<div class="line"><span class="lineno">   65</span> </div>
<div class="line"><span class="lineno">   66</span>            <span class="comment">//subtract the current demand from our capacity so that we can know when we have to end this subtour</span></div>
<div class="line"><span class="lineno">   67</span>            capacity -= current.<a class="code hl_variable" href="struct_node.html#a743d222e005f1160358a82d9329e5191">demand</a>;</div>
<div class="line"><span class="lineno">   68</span> </div>
<div class="line"><span class="lineno">   69</span>            <span class="comment">//&quot;visit&quot; the current node</span></div>
<div class="line"><span class="lineno">   70</span>            subtour.push_back(current);</div>
<div class="line"><span class="lineno">   71</span>            visited_nodes.push_back(current);</div>
<div class="line"><span class="lineno">   72</span> </div>
<div class="line"><span class="lineno">   73</span>            <span class="comment">//if we have visited all the customer nodes, this is the end of the current subtour</span></div>
<div class="line"><span class="lineno">   74</span>            <span class="keywordflow">if</span> (visited_nodes.size() == customer_nodes.size())</div>
<div class="line"><span class="lineno">   75</span>            {</div>
<div class="line"><span class="lineno">   76</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">   77</span>            }</div>
<div class="line"><span class="lineno">   78</span>        }</div>
<div class="line"><span class="lineno">   79</span>        <span class="comment">//add current subtour to collection of all subtours</span></div>
<div class="line"><span class="lineno">   80</span>        subtours.push_back(subtour);</div>
<div class="line"><span class="lineno">   81</span>    }</div>
<div class="line"><span class="lineno">   82</span> </div>
<div class="line"><span class="lineno">   83</span>    <span class="comment">/*</span></div>
<div class="line"><span class="lineno">   84</span><span class="comment">    * End of Nearest Neighbor Subtour generation, but we should assert that we did it correctly</span></div>
<div class="line"><span class="lineno">   85</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">   86</span> </div>
<div class="line"><span class="lineno">   87</span>    <span class="comment">//assert that we have the proper number of nodes in the full tour</span></div>
<div class="line"><span class="lineno">   88</span>    <span class="keywordtype">int</span> node_count = 0;</div>
<div class="line"><span class="lineno">   89</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sub : subtours)</div>
<div class="line"><span class="lineno">   90</span>    {</div>
<div class="line"><span class="lineno">   91</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; n : sub)</div>
<div class="line"><span class="lineno">   92</span>        {</div>
<div class="line"><span class="lineno">   93</span>            node_count++;</div>
<div class="line"><span class="lineno">   94</span>        }</div>
<div class="line"><span class="lineno">   95</span>    }</div>
<div class="line"><span class="lineno">   96</span>    cout &lt;&lt; <span class="stringliteral">&quot;Sum of all nodes in subtours: &quot;</span> &lt;&lt; node_count &lt;&lt; endl;</div>
<div class="line"><span class="lineno">   97</span>    assert(node_count == customer_nodes.size());</div>
<div class="line"><span class="lineno">   98</span> </div>
<div class="line"><span class="lineno">   99</span>    <span class="comment">//assert that each customer is visited once and only once. if this is not the case, we have broken one of the critical</span></div>
<div class="line"><span class="lineno">  100</span>    <span class="comment">//constraints of the problem</span></div>
<div class="line"><span class="lineno">  101</span>    vector&lt;Node&gt; all_nodes_in_subtour;</div>
<div class="line"><span class="lineno">  102</span>    <span class="keywordtype">bool</span> any_duplicate_node = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  103</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sub : subtours)</div>
<div class="line"><span class="lineno">  104</span>    {</div>
<div class="line"><span class="lineno">  105</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; n : sub)</div>
<div class="line"><span class="lineno">  106</span>        {</div>
<div class="line"><span class="lineno">  107</span>            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; temp : all_nodes_in_subtour)</div>
<div class="line"><span class="lineno">  108</span>            {</div>
<div class="line"><span class="lineno">  109</span>                <span class="keywordflow">if</span> (temp.index == n.index)</div>
<div class="line"><span class="lineno">  110</span>                {</div>
<div class="line"><span class="lineno">  111</span>                    cout &lt;&lt; <span class="stringliteral">&quot;Duplicate node detected: &quot;</span> &lt;&lt; temp.index &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  112</span>                    any_duplicate_node = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  113</span>                }</div>
<div class="line"><span class="lineno">  114</span>            }</div>
<div class="line"><span class="lineno">  115</span>            all_nodes_in_subtour.push_back(n);</div>
<div class="line"><span class="lineno">  116</span>        }</div>
<div class="line"><span class="lineno">  117</span>    }</div>
<div class="line"><span class="lineno">  118</span>    assert(any_duplicate_node == <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">  119</span> </div>
<div class="line"><span class="lineno">  120</span> </div>
<div class="line"><span class="lineno">  121</span> </div>
<div class="line"><span class="lineno">  122</span>    <span class="comment">//now we have all of the subtours required for this route</span></div>
<div class="line"><span class="lineno">  123</span>    <span class="comment">//we now need to implement NEH concepts to find the best ordering of each element in each subtour</span></div>
<div class="line"><span class="lineno">  124</span>    vector&lt;vector&lt;int&gt;&gt; optimal_subtours;</div>
<div class="line"><span class="lineno">  125</span>    optimal_subtours.reserve(subtours.size());</div>
<div class="line"><span class="lineno">  126</span> </div>
<div class="line"><span class="lineno">  127</span>    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;subtour : subtours)</div>
<div class="line"><span class="lineno">  128</span>    {</div>
<div class="line"><span class="lineno">  129</span>        optimal_subtours.push_back(<a class="code hl_function" href="class_n_e_h___nearest_neighbor.html#ac5e7990cabd81eec17a0a9b22610cacd">NEH_Calculation</a>(subtour));</div>
<div class="line"><span class="lineno">  130</span>    }</div>
<div class="line"><span class="lineno">  131</span> </div>
<div class="line"><span class="lineno">  132</span>    <span class="comment">//now we have all of the subtours optimized as far as NEH can, so now we</span></div>
<div class="line"><span class="lineno">  133</span>    <span class="comment">//combine them all into one complete tour and calculate the distance</span></div>
<div class="line"><span class="lineno">  134</span>    vector&lt;int&gt; tour;</div>
<div class="line"><span class="lineno">  135</span>    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;subtour : optimal_subtours)</div>
<div class="line"><span class="lineno">  136</span>    {</div>
<div class="line"><span class="lineno">  137</span>        <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;node : subtour)</div>
<div class="line"><span class="lineno">  138</span>        {</div>
<div class="line"><span class="lineno">  139</span>            tour.push_back(node);</div>
<div class="line"><span class="lineno">  140</span>        }</div>
<div class="line"><span class="lineno">  141</span>    }</div>
<div class="line"><span class="lineno">  142</span>    bestTour = tour;</div>
<div class="line"><span class="lineno">  143</span>    bestDistance = <a class="code hl_variable" href="class_algorithm_base.html#a0f24e23a948de9928cac6fa78422e292">vehicle</a>-&gt;<a class="code hl_function" href="class_vehicle.html#a9e45048058f35d303d2c17ea1f7e657d">SimulateDrive</a>(bestTour);</div>
<div class="line"><span class="lineno">  144</span>    cout &lt;&lt; bestDistance &lt;&lt; endl;</div>
<div class="line"><span class="lineno">  145</span>}</div>
<div class="ttc" id="a_graph_structure_8h_html_aa06f172ac3f4b3ebef947ceb37e8d311"><div class="ttname"><a href="_graph_structure_8h.html#aa06f172ac3f4b3ebef947ceb37e8d311">EVRP_Data::nodes</a></div><div class="ttdeci">vector&lt; Node &gt; nodes</div><div class="ttdef"><b>Definition</b> GraphStructure.h:71</div></div>
<div class="ttc" id="a_graph_structure_8h_html_ab01f753d693662a727c4ee4883562ab5"><div class="ttname"><a href="_graph_structure_8h.html#ab01f753d693662a727c4ee4883562ab5">EVRP_Data::loadCapacity</a></div><div class="ttdeci">int loadCapacity</div><div class="ttdef"><b>Definition</b> GraphStructure.h:73</div></div>
<div class="ttc" id="aclass_algorithm_base_html_ad83df42564aa8a94f169ab78b4625731"><div class="ttname"><a href="class_algorithm_base.html#ad83df42564aa8a94f169ab78b4625731">AlgorithmBase::problem_data</a></div><div class="ttdeci">EVRP_Data problem_data</div><div class="ttdef"><b>Definition</b> AlgorithmBase.h:28</div></div>
<div class="ttc" id="aclass_n_e_h___nearest_neighbor_html_aabdd648e7d16ac1c0020bcf6e2b8df39"><div class="ttname"><a href="class_n_e_h___nearest_neighbor.html#aabdd648e7d16ac1c0020bcf6e2b8df39">NEH_NearestNeighbor::GetNearestUnvisitedNode</a></div><div class="ttdeci">static Node GetNearestUnvisitedNode(const vector&lt; Node &gt; &amp;customer_nodes, const vector&lt; Node &gt; &amp;visited_nodes, const Node &amp;node)</div><div class="ttdoc">Find the closest node to the provided node while filtering the graph by nodes we have already visited...</div><div class="ttdef"><b>Definition</b> NEH_NearestNeighbor.cpp:154</div></div>
<div class="ttc" id="aclass_n_e_h___nearest_neighbor_html_ac5e7990cabd81eec17a0a9b22610cacd"><div class="ttname"><a href="class_n_e_h___nearest_neighbor.html#ac5e7990cabd81eec17a0a9b22610cacd">NEH_NearestNeighbor::NEH_Calculation</a></div><div class="ttdeci">vector&lt; int &gt; NEH_Calculation(const vector&lt; Node &gt; &amp;subtour) const</div><div class="ttdoc">Use NEH concepts to find the best ordering of nodes in each subtour. we need to figure out the optima...</div><div class="ttdef"><b>Definition</b> NEH_NearestNeighbor.cpp:206</div></div>
<div class="ttc" id="astruct_node_html_a743d222e005f1160358a82d9329e5191"><div class="ttname"><a href="struct_node.html#a743d222e005f1160358a82d9329e5191">Node::demand</a></div><div class="ttdeci">int demand</div><div class="ttdef"><b>Definition</b> GraphStructure.h:37</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="struct_node.html#a743d222e005f1160358a82d9329e5191">Node::demand</a>, <a class="el" href="class_n_e_h___nearest_neighbor.html#aabdd648e7d16ac1c0020bcf6e2b8df39">GetNearestUnvisitedNode()</a>, <a class="el" href="_graph_structure_8h.html#ab01f753d693662a727c4ee4883562ab5">EVRP_Data::loadCapacity</a>, <a class="el" href="class_n_e_h___nearest_neighbor.html#ac5e7990cabd81eec17a0a9b22610cacd">NEH_Calculation()</a>, <a class="el" href="_graph_structure_8h.html#aa06f172ac3f4b3ebef947ceb37e8d311">EVRP_Data::nodes</a>, <a class="el" href="class_algorithm_base.html#ad83df42564aa8a94f169ab78b4625731">AlgorithmBase::problem_data</a>, <a class="el" href="class_vehicle.html#a9e45048058f35d303d2c17ea1f7e657d">Vehicle::SimulateDrive()</a>, and <a class="el" href="class_algorithm_base.html#a0f24e23a948de9928cac6fa78422e292">AlgorithmBase::vehicle</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>EVRP/Algorithms/NEH/<a class="el" href="_n_e_h___nearest_neighbor_8h_source.html">NEH_NearestNeighbor.h</a></li>
<li>EVRP/Algorithms/NEH/<a class="el" href="_n_e_h___nearest_neighbor_8cpp.html">NEH_NearestNeighbor.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_n_e_h___nearest_neighbor.html">NEH_NearestNeighbor</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
